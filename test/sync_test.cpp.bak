#include "sync.hpp"
#include "type_name.hpp"

#include <boost/ut.hpp>

#include <algorithm>
#include <concepts>
#include <format>
#include <functional>
#include <iostream>
#include <shared_mutex>
#include <string>
#include <tuple>
#include <utility>

#ifndef ENABLE_DEADLOCK_CODE
#    define ENABLE_DEADLOCK_CODE 0
#endif

template <typename... Args>
void print(std::format_string<Args...>&& fmt, Args... args)
{
    std::cout << std::format(std::forward<std::format_string<Args...>>(fmt), std::forward<Args>(args)...);
}

class Mutex : public std::shared_mutex
{
public:
    Mutex()                        = default;
    Mutex(const Mutex&)            = delete;
    Mutex& operator=(const Mutex&) = delete;
    Mutex(Mutex&&)                 = delete;
    Mutex& operator=(Mutex&&)      = delete;

    void lock()
    {
        print(">>> unique lock\n");
        std::shared_mutex::lock();
    }

    void unlock()
    {
        print("<<< unique unlock\n");
        std::shared_mutex::unlock();
    }

    void lock_shared()
    {
        print("+++ shared lock\n");
        std::shared_mutex::lock_shared();
    }

    void unlock_shared()
    {
        print("--- shared unlock\n");
        std::shared_mutex::unlock_shared();
    }
};

struct AClass
{
    AClass() { print("\tAClass Constructing\n"); }
    AClass(const AClass&) { print("\tAClass Copying\n"); }
    void doSomething() { print("\tAClass Doing something\n"); }
};

struct BClass
{
};

class SomeClass
{
public:
    inline static int m_idCounter{ 0 };
    int               m_id;

    explicit SomeClass(std::string name, int value)
        : m_id{ ++m_idCounter }
        , m_name{ std::move(name) }
        , m_value{ value }
    {
        print("\tSomeClass Constructing '{}'\n", m_name);
    }

    SomeClass(SomeClass&& other) noexcept
        : m_name{ std::move(other.m_name) }
        , m_value{ other.m_value }
    {
        print("\tSomeClass Move constructing '{}'\n", m_name);
    }

    SomeClass& operator=(SomeClass&& other) noexcept
    {
        print("\tSomeClass Move assigning '{}' to '{}'\n", other.m_name, m_name);
        m_name  = std::move(other.m_name);
        m_value = other.m_value;
        return *this;
    }

    BClass doModification()
    {
        m_value++;
        std::reverse(m_name.begin(), m_name.end());
        print("\tSomeClass Doing something '{}'\n", m_value);
        return {};
    }

    AClass doConstOperation() const
    {
        print("\tSomeClass Doing something const: '{}' | '{}'\n", m_value, m_name);
        return {};
    }

    void doSomethingWithArgs(AClass& /* aClass */, int v)
    {
        m_value += v;
        print("\tSomeClass Doing something with args: '{}' '{}'\n", m_value, v);
    }

    const std::string& getName() const { return m_name; }
    std::string        getNameCopy() const { return m_name; }

private:
    std::string m_name;
    int         m_value;
};

template <typename... Args>
std::string fmt(std::format_string<Args...>&& fmt, Args&&... args)
{
    return std::format(std::forward<std::format_string<Args...>>(fmt), std::forward<Args>(args)...);
};

int main()
{
    namespace ut = boost::ut;
    using namespace ut::literals;

    ut::suite<"Sync Construction"> syncConstruction [[maybe_unused]] = [] {
        using Resource = SomeClass;
        using SyncSome = Sync<SomeClass, Mutex>;

        "Forward construction"_test = [&] {
            ut::expect(true == std::constructible_from<SyncSome, std::string, int>)
                << fmt("Construction with '{}' ctor arguments is not possible when it should be!",
                       type_name<Resource>());
        };

        "Resource move construction"_test = [&] {
            ut::expect(true == std::constructible_from<SyncSome, Resource&&>)
                << fmt("Construction from moved '{}' instance is not possible when it should be!",
                       type_name<Resource&&>());
        };

        "Resource copy construction"_test = [&] {
            using R1 = Resource;
            ut::expect(false == std::constructible_from<SyncSome, R1>) << fmt("construction from '{}'", type_name<R1>);

            using R2 = Resource&;
            ut::expect(false == std::constructible_from<SyncSome, R2>)
                << fmt("Construction from reference of '{}'", rName);
        };
    };

#ifdef asdkfjhadskjfh

    // construction by moving the to-be-synced object
    SomeClass someClass2{ "SomeClass instance 2", 42 };
    Sync      synced2{ std::move(someClass2) };    // can't copy the resource, remove std::move to do it

    synced2 = SomeClass{ "SomeClass instance 3", 42 };    // OK: call to move assignment operator
    // Sync<SomeClass> synced3{ std::move(synced2) };    // FAIL: call to deleted move constructor

    // read from or write to the synced object using lambda
    std::ignore = synced.read([](auto& v) {    // auto& is deduced to const SomeClass&, I can't constraint this behavior
        print("[DEBUG] {} at {}: decltype(v) = {}\n", __FILE__, __LINE__, type_name(v));
        return v.doConstOperation();
    });
    std::ignore = synced.write([](auto& v) {
        v.doModification();
        return true;
    });

    // invoke the member function through read (const) or write (non-const)
    auto aClass = synced.read(&SomeClass::doConstOperation);    // OK: using read to invoke const member function
    // std::ignore = synced.read(&SomeClass::doModification);   // FAIL: using read to invoke non-const member function

    std::ignore = synced.write(&SomeClass::doModification);      // OK: using write to invoke non-const member function
    std::ignore = synced.write(&SomeClass::doConstOperation);    // OK: using write to invoke const member function

    // invoke the member function with arguments (constness matters)
    synced.write(&SomeClass::doSomethingWithArgs, aClass, 42);    // OK: using write to invoke non-const member function
    // synced.read(&SomeClass::doSomethingWithArgs, aClass, 42);  // FAIL: using read to invoke non-const member func

    // auto name  = synced.read(&SomeClass::getName);         // FAIL: member function returns a reference
    // auto name2 = synced.write(&SomeClass::getName);        // FAIL: member function returns a reference
    auto name  = synced.read(&SomeClass::getNameCopy);     // OK: member function NOT returns a reference
    auto name2 = synced.write(&SomeClass::getNameCopy);    // OK: member function NOT returns a reference

    auto name3 = synced.read([](const SomeClass& c) { return c.getName(); });         // OK: returns copy
    auto name4 = synced.write([](const SomeClass& c) { return c.getName(); });        // OK: returns copy
    auto name5 = synced.read([](const SomeClass& c) { return c.getNameCopy(); });     // OK: returns copy
    auto name6 = synced.write([](const SomeClass& c) { return c.getNameCopy(); });    // OK: returns copy

    // multiple reader (recursive locks) (will deadlock if using std::mutex but not if using std::shared_mutex)
    if constexpr (std::derived_from<typename decltype(synced)::Mutex_type, std::shared_mutex>) {
        synced.read([&synced](const auto& v) {
            using M = decltype(synced)::Mutex_type;
            print(
                "[DEBUG]: recursive locks using {} ({})\n",
                type_name<M>(),
                std::derived_from<M, std::shared_mutex> ? "won't deadlock" : "deadlock"
            );
            v.doConstOperation();
            std::ignore = synced.read([](const auto& v) { return v.doConstOperation(); });
            std::ignore = synced.read(&SomeClass::doConstOperation);
        });
    } else {
        print("[DEBUG]: using std::mutex: skipping recursive lock test\n");
    }

    // writer and reader deadlock (throws if std::shared_mutex is used)
    if constexpr (ENABLE_DEADLOCK_CODE) {
        synced.write([&synced](auto&) {
            print("[DEBUG]: deadlock! you can't recover from this!\n");
            std::ignore = synced.read([](const auto& v) { return v.doConstOperation(); });
            std::ignore = synced.read(&SomeClass::doConstOperation);
        });
    } else {
        print("[DEBUG]: ENABLE_DEADLOCK_CODE is disabled: skipping deadlock test\n");
    }

    // another writer and reader deadlock (no throws! silent bug!)
    if constexpr (ENABLE_DEADLOCK_CODE) {
        synced.read([&synced](const auto&) {
            print("[DEBUG]: deadlock! you can't recover from this!\n");
            std::ignore = synced.write(&SomeClass::doModification);
            std::ignore = synced.read(&SomeClass::doConstOperation);
        });
    }
    {
        print("[DEBUG]: ENABLE_DEADLOCK_CODE is disabled: skipping deadlock test\n");
    }
#endif
}
